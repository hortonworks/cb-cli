package models_cloudbreak

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-swagger/go-swagger/strfmt"
	"github.com/go-swagger/go-swagger/swag"

	"github.com/go-swagger/go-swagger/errors"
	"github.com/go-swagger/go-swagger/httpkit/validate"
)

/*LdapConfigRequest ldap config request

swagger:model LdapConfigRequest
*/
type LdapConfigRequest struct {

	/* bind distinguished name for connection test and group search (e.g. cn=admin,dc=example,dc=org)

	Required: true
	*/
	BindDn string `json:"bindDn"`

	/* password for the provided bind DN

	Required: true
	*/
	BindPassword string `json:"bindPassword"`

	/* description of the resource

	Max Length: 1000
	Min Length: 0
	*/
	Description *string `json:"description,omitempty"`

	/* domain in LDAP server (e.g. ad.seq.com).
	 */
	Domain *string `json:"domain,omitempty"`

	/* template for group search for authorization (e.g. dc=hadoop,dc=apache,dc=org)
	 */
	GroupSearchBase *string `json:"groupSearchBase,omitempty"`

	/* filter for group search for authorization
	 */
	GroupSearchFilter *string `json:"groupSearchFilter,omitempty"`

	/* name of the resource

	Required: true
	Max Length: 100
	Min Length: 1
	*/
	Name string `json:"name"`

	/* parses the principal for insertion into templates via regex.
	 */
	PrincipalRegex *string `json:"principalRegex,omitempty"`

	/* public host or IP address of LDAP server

	Required: true
	*/
	ServerHost string `json:"serverHost"`

	/* port of LDAP server (typically: 389 or 636 for LDAPS)

	Required: true
	Maximum: 65535
	Minimum: 1
	*/
	ServerPort int32 `json:"serverPort"`

	/* determines if LDAP or LDAP over SSL is to be used
	 */
	ServerSSL *bool `json:"serverSSL,omitempty"`

	/* attribute name for simplified search filter (e.g. sAMAccountName).
	 */
	UserSearchAttribute *string `json:"userSearchAttribute,omitempty"`

	/* template for user search for authentication (e.g. dc=hadoop,dc=apache,dc=org)

	Required: true
	*/
	UserSearchBase string `json:"userSearchBase"`

	/* filter for user search for authentication (e.g. (&amp;(objectclass=person)(sAMAccountName={2})) )
	 */
	UserSearchFilter *string `json:"userSearchFilter,omitempty"`
}

// Validate validates this ldap config request
func (m *LdapConfigRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBindDn(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBindPassword(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateServerHost(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateServerPort(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateUserSearchBase(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *LdapConfigRequest) validateBindDn(formats strfmt.Registry) error {

	if err := validate.RequiredString("bindDn", "body", string(m.BindDn)); err != nil {
		return err
	}

	return nil
}

func (m *LdapConfigRequest) validateBindPassword(formats strfmt.Registry) error {

	if err := validate.RequiredString("bindPassword", "body", string(m.BindPassword)); err != nil {
		return err
	}

	return nil
}

func (m *LdapConfigRequest) validateDescription(formats strfmt.Registry) error {

	if swag.IsZero(m.Description) { // not required
		return nil
	}

	if err := validate.MinLength("description", "body", string(*m.Description), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("description", "body", string(*m.Description), 1000); err != nil {
		return err
	}

	return nil
}

func (m *LdapConfigRequest) validateName(formats strfmt.Registry) error {

	if err := validate.RequiredString("name", "body", string(m.Name)); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", string(m.Name), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", string(m.Name), 100); err != nil {
		return err
	}

	return nil
}

func (m *LdapConfigRequest) validateServerHost(formats strfmt.Registry) error {

	if err := validate.RequiredString("serverHost", "body", string(m.ServerHost)); err != nil {
		return err
	}

	return nil
}

func (m *LdapConfigRequest) validateServerPort(formats strfmt.Registry) error {

	if err := validate.Required("serverPort", "body", int32(m.ServerPort)); err != nil {
		return err
	}

	if err := validate.MinimumInt("serverPort", "body", int64(m.ServerPort), 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("serverPort", "body", int64(m.ServerPort), 65535, false); err != nil {
		return err
	}

	return nil
}

func (m *LdapConfigRequest) validateUserSearchBase(formats strfmt.Registry) error {

	if err := validate.RequiredString("userSearchBase", "body", string(m.UserSearchBase)); err != nil {
		return err
	}

	return nil
}
