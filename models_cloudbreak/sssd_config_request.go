package models_cloudbreak

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-swagger/go-swagger/strfmt"
	"github.com/go-swagger/go-swagger/swag"

	"github.com/go-swagger/go-swagger/errors"
	"github.com/go-swagger/go-swagger/httpkit/validate"
)

/*SssdConfigRequest sssd config request

swagger:model SssdConfigRequest
*/
type SssdConfigRequest struct {

	/* comma-separated list of IP addresses or hostnames of the AD servers

	Max Length: 255
	Min Length: 0
	*/
	AdServer *string `json:"adServer,omitempty"`

	/* search base of the database

	Max Length: 255
	Min Length: 10
	*/
	BaseSearch string `json:"baseSearch,omitempty"`

	/* custom configuration
	 */
	Configuration *string `json:"configuration,omitempty"`

	/* description of the resource

	Max Length: 1000
	Min Length: 0
	*/
	Description *string `json:"description,omitempty"`

	/* name of the Kerberos realm

	Max Length: 255
	Min Length: 0
	*/
	KerberosRealm *string `json:"kerberosRealm,omitempty"`

	/* comma-separated list of IP addresses or hostnames of the Kerberos servers

	Max Length: 255
	Min Length: 0
	*/
	KerberosServer *string `json:"kerberosServer,omitempty"`

	/* name of the resource

	Required: true
	Max Length: 100
	Min Length: 1
	Pattern: ([a-z][-a-z0-9]*[a-z0-9])
	*/
	Name string `json:"name"`

	/* provider type
	 */
	ProviderType *string `json:"providerType,omitempty"`

	/* schema of the database
	 */
	Schema *string `json:"schema,omitempty"`

	/* TLS behavior of the connection
	 */
	TLSReqcert *string `json:"tlsReqcert,omitempty"`

	/* comma-separated list of URIs of the LDAP servers

	Max Length: 255
	Min Length: 10
	*/
	URL string `json:"url,omitempty"`
}

// Validate validates this sssd config request
func (m *SssdConfigRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdServer(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBaseSearch(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateKerberosRealm(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateKerberosServer(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProviderType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSchema(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTLSReqcert(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateURL(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SssdConfigRequest) validateAdServer(formats strfmt.Registry) error {

	if swag.IsZero(m.AdServer) { // not required
		return nil
	}

	if err := validate.MinLength("adServer", "body", string(*m.AdServer), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("adServer", "body", string(*m.AdServer), 255); err != nil {
		return err
	}

	return nil
}

func (m *SssdConfigRequest) validateBaseSearch(formats strfmt.Registry) error {

	if swag.IsZero(m.BaseSearch) { // not required
		return nil
	}

	if err := validate.MinLength("baseSearch", "body", string(m.BaseSearch), 10); err != nil {
		return err
	}

	if err := validate.MaxLength("baseSearch", "body", string(m.BaseSearch), 255); err != nil {
		return err
	}

	return nil
}

func (m *SssdConfigRequest) validateDescription(formats strfmt.Registry) error {

	if swag.IsZero(m.Description) { // not required
		return nil
	}

	if err := validate.MinLength("description", "body", string(*m.Description), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("description", "body", string(*m.Description), 1000); err != nil {
		return err
	}

	return nil
}

func (m *SssdConfigRequest) validateKerberosRealm(formats strfmt.Registry) error {

	if swag.IsZero(m.KerberosRealm) { // not required
		return nil
	}

	if err := validate.MinLength("kerberosRealm", "body", string(*m.KerberosRealm), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("kerberosRealm", "body", string(*m.KerberosRealm), 255); err != nil {
		return err
	}

	return nil
}

func (m *SssdConfigRequest) validateKerberosServer(formats strfmt.Registry) error {

	if swag.IsZero(m.KerberosServer) { // not required
		return nil
	}

	if err := validate.MinLength("kerberosServer", "body", string(*m.KerberosServer), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("kerberosServer", "body", string(*m.KerberosServer), 255); err != nil {
		return err
	}

	return nil
}

func (m *SssdConfigRequest) validateName(formats strfmt.Registry) error {

	if err := validate.RequiredString("name", "body", string(m.Name)); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", string(m.Name), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", string(m.Name), 100); err != nil {
		return err
	}

	if err := validate.Pattern("name", "body", string(m.Name), `([a-z][-a-z0-9]*[a-z0-9])`); err != nil {
		return err
	}

	return nil
}

var sssdConfigRequestTypeProviderTypePropEnum []interface{}

func (m *SssdConfigRequest) validateProviderTypeEnum(path, location string, value string) error {
	if sssdConfigRequestTypeProviderTypePropEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["LDAP","ACTIVE_DIRECTORY","IPA"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			sssdConfigRequestTypeProviderTypePropEnum = append(sssdConfigRequestTypeProviderTypePropEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, sssdConfigRequestTypeProviderTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SssdConfigRequest) validateProviderType(formats strfmt.Registry) error {

	if swag.IsZero(m.ProviderType) { // not required
		return nil
	}

	if err := m.validateProviderTypeEnum("providerType", "body", *m.ProviderType); err != nil {
		return err
	}

	return nil
}

var sssdConfigRequestTypeSchemaPropEnum []interface{}

func (m *SssdConfigRequest) validateSchemaEnum(path, location string, value string) error {
	if sssdConfigRequestTypeSchemaPropEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["RFC2307","RFC2307BIS","IPA","AD"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			sssdConfigRequestTypeSchemaPropEnum = append(sssdConfigRequestTypeSchemaPropEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, sssdConfigRequestTypeSchemaPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SssdConfigRequest) validateSchema(formats strfmt.Registry) error {

	if swag.IsZero(m.Schema) { // not required
		return nil
	}

	if err := m.validateSchemaEnum("schema", "body", *m.Schema); err != nil {
		return err
	}

	return nil
}

var sssdConfigRequestTypeTLSReqcertPropEnum []interface{}

func (m *SssdConfigRequest) validateTLSReqcertEnum(path, location string, value string) error {
	if sssdConfigRequestTypeTLSReqcertPropEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["NEVER","ALLOW","TRY","DEMAND","HARD"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			sssdConfigRequestTypeTLSReqcertPropEnum = append(sssdConfigRequestTypeTLSReqcertPropEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, sssdConfigRequestTypeTLSReqcertPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SssdConfigRequest) validateTLSReqcert(formats strfmt.Registry) error {

	if swag.IsZero(m.TLSReqcert) { // not required
		return nil
	}

	if err := m.validateTLSReqcertEnum("tlsReqcert", "body", *m.TLSReqcert); err != nil {
		return err
	}

	return nil
}

func (m *SssdConfigRequest) validateURL(formats strfmt.Registry) error {

	if swag.IsZero(m.URL) { // not required
		return nil
	}

	if err := validate.MinLength("url", "body", string(m.URL), 10); err != nil {
		return err
	}

	if err := validate.MaxLength("url", "body", string(m.URL), 255); err != nil {
		return err
	}

	return nil
}
