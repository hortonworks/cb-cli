package models_cloudbreak

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-swagger/go-swagger/strfmt"
	"github.com/go-swagger/go-swagger/swag"

	"github.com/go-swagger/go-swagger/errors"
	"github.com/go-swagger/go-swagger/httpkit/validate"
)

/*SssdConfigResponse sssd config response

swagger:model SssdConfigResponse
*/
type SssdConfigResponse struct {

	/* comma-separated list of IP addresses or hostnames of the AD servers

	Max Length: 255
	Min Length: 0
	*/
	AdServer *string `json:"adServer,omitempty"`

	/* search base of the database

	Max Length: 255
	Min Length: 10
	*/
	BaseSearch string `json:"baseSearch,omitempty"`

	/* custom configuration
	 */
	Configuration *string `json:"configuration,omitempty"`

	/* description of the resource

	Max Length: 1000
	Min Length: 0
	*/
	Description *string `json:"description,omitempty"`

	/* id of the resource
	 */
	ID *int64 `json:"id,omitempty"`

	/* name of the Kerberos realm

	Max Length: 255
	Min Length: 0
	*/
	KerberosRealm *string `json:"kerberosRealm,omitempty"`

	/* comma-separated list of IP addresses or hostnames of the Kerberos servers

	Max Length: 255
	Min Length: 0
	*/
	KerberosServer *string `json:"kerberosServer,omitempty"`

	/* name of the resource

	Required: true
	Max Length: 100
	Min Length: 1
	Pattern: ([a-z][-a-z0-9]*[a-z0-9])
	*/
	Name string `json:"name"`

	/* provider type
	 */
	ProviderType *string `json:"providerType,omitempty"`

	/* resource is visible in account
	 */
	Public *bool `json:"public,omitempty"`

	/* schema of the database
	 */
	Schema *string `json:"schema,omitempty"`

	/* TLS behavior of the connection
	 */
	TLSReqcert *string `json:"tlsReqcert,omitempty"`

	/* comma-separated list of URIs of the LDAP servers

	Max Length: 255
	Min Length: 10
	*/
	URL string `json:"url,omitempty"`
}

// Validate validates this sssd config response
func (m *SssdConfigResponse) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAdServer(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBaseSearch(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateKerberosRealm(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateKerberosServer(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProviderType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSchema(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTLSReqcert(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateURL(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SssdConfigResponse) validateAdServer(formats strfmt.Registry) error {

	if swag.IsZero(m.AdServer) { // not required
		return nil
	}

	if err := validate.MinLength("adServer", "body", string(*m.AdServer), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("adServer", "body", string(*m.AdServer), 255); err != nil {
		return err
	}

	return nil
}

func (m *SssdConfigResponse) validateBaseSearch(formats strfmt.Registry) error {

	if swag.IsZero(m.BaseSearch) { // not required
		return nil
	}

	if err := validate.MinLength("baseSearch", "body", string(m.BaseSearch), 10); err != nil {
		return err
	}

	if err := validate.MaxLength("baseSearch", "body", string(m.BaseSearch), 255); err != nil {
		return err
	}

	return nil
}

func (m *SssdConfigResponse) validateDescription(formats strfmt.Registry) error {

	if swag.IsZero(m.Description) { // not required
		return nil
	}

	if err := validate.MinLength("description", "body", string(*m.Description), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("description", "body", string(*m.Description), 1000); err != nil {
		return err
	}

	return nil
}

func (m *SssdConfigResponse) validateKerberosRealm(formats strfmt.Registry) error {

	if swag.IsZero(m.KerberosRealm) { // not required
		return nil
	}

	if err := validate.MinLength("kerberosRealm", "body", string(*m.KerberosRealm), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("kerberosRealm", "body", string(*m.KerberosRealm), 255); err != nil {
		return err
	}

	return nil
}

func (m *SssdConfigResponse) validateKerberosServer(formats strfmt.Registry) error {

	if swag.IsZero(m.KerberosServer) { // not required
		return nil
	}

	if err := validate.MinLength("kerberosServer", "body", string(*m.KerberosServer), 0); err != nil {
		return err
	}

	if err := validate.MaxLength("kerberosServer", "body", string(*m.KerberosServer), 255); err != nil {
		return err
	}

	return nil
}

func (m *SssdConfigResponse) validateName(formats strfmt.Registry) error {

	if err := validate.RequiredString("name", "body", string(m.Name)); err != nil {
		return err
	}

	if err := validate.MinLength("name", "body", string(m.Name), 1); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", string(m.Name), 100); err != nil {
		return err
	}

	if err := validate.Pattern("name", "body", string(m.Name), `([a-z][-a-z0-9]*[a-z0-9])`); err != nil {
		return err
	}

	return nil
}

var sssdConfigResponseTypeProviderTypePropEnum []interface{}

func (m *SssdConfigResponse) validateProviderTypeEnum(path, location string, value string) error {
	if sssdConfigResponseTypeProviderTypePropEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["LDAP","ACTIVE_DIRECTORY","IPA"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			sssdConfigResponseTypeProviderTypePropEnum = append(sssdConfigResponseTypeProviderTypePropEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, sssdConfigResponseTypeProviderTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SssdConfigResponse) validateProviderType(formats strfmt.Registry) error {

	if swag.IsZero(m.ProviderType) { // not required
		return nil
	}

	if err := m.validateProviderTypeEnum("providerType", "body", *m.ProviderType); err != nil {
		return err
	}

	return nil
}

var sssdConfigResponseTypeSchemaPropEnum []interface{}

func (m *SssdConfigResponse) validateSchemaEnum(path, location string, value string) error {
	if sssdConfigResponseTypeSchemaPropEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["RFC2307","RFC2307BIS","IPA","AD"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			sssdConfigResponseTypeSchemaPropEnum = append(sssdConfigResponseTypeSchemaPropEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, sssdConfigResponseTypeSchemaPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SssdConfigResponse) validateSchema(formats strfmt.Registry) error {

	if swag.IsZero(m.Schema) { // not required
		return nil
	}

	if err := m.validateSchemaEnum("schema", "body", *m.Schema); err != nil {
		return err
	}

	return nil
}

var sssdConfigResponseTypeTLSReqcertPropEnum []interface{}

func (m *SssdConfigResponse) validateTLSReqcertEnum(path, location string, value string) error {
	if sssdConfigResponseTypeTLSReqcertPropEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["NEVER","ALLOW","TRY","DEMAND","HARD"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			sssdConfigResponseTypeTLSReqcertPropEnum = append(sssdConfigResponseTypeTLSReqcertPropEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, sssdConfigResponseTypeTLSReqcertPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *SssdConfigResponse) validateTLSReqcert(formats strfmt.Registry) error {

	if swag.IsZero(m.TLSReqcert) { // not required
		return nil
	}

	if err := m.validateTLSReqcertEnum("tlsReqcert", "body", *m.TLSReqcert); err != nil {
		return err
	}

	return nil
}

func (m *SssdConfigResponse) validateURL(formats strfmt.Registry) error {

	if swag.IsZero(m.URL) { // not required
		return nil
	}

	if err := validate.MinLength("url", "body", string(m.URL), 10); err != nil {
		return err
	}

	if err := validate.MaxLength("url", "body", string(m.URL), 255); err != nil {
		return err
	}

	return nil
}
