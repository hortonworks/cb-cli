// Code generated by go-swagger; DO NOT EDIT.

package database_servers

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new database servers API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for database servers API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
CreateDatabaseOnServer creates a database on an existing database server

Creates a new database on a database server. The database starts out empty. A new user with credentials separate from the database server's administrative user is also created, with full rights to the new database.
*/
func (a *Client) CreateDatabaseOnServer(params *CreateDatabaseOnServerParams, authInfo runtime.ClientAuthInfoWriter) (*CreateDatabaseOnServerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDatabaseOnServerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createDatabaseOnServer",
		Method:             "POST",
		PathPattern:        "/v4/databaseservers/createDatabase",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateDatabaseOnServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateDatabaseOnServerOK), nil

}

/*
CreateDatabaseServer creates and register a database server in a cloud provider

Creates a new database server. The database server starts out with only default databases.
*/
func (a *Client) CreateDatabaseServer(params *CreateDatabaseServerParams, authInfo runtime.ClientAuthInfoWriter) (*CreateDatabaseServerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDatabaseServerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createDatabaseServer",
		Method:             "POST",
		PathPattern:        "/v4/databaseservers/managed",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateDatabaseServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateDatabaseServerOK), nil

}

/*
CreateDatabaseServerInternal creates and register a database server in a cloud provider with internal actor

Creates a new database server. The database server starts out with only default databases.
*/
func (a *Client) CreateDatabaseServerInternal(params *CreateDatabaseServerInternalParams, authInfo runtime.ClientAuthInfoWriter) (*CreateDatabaseServerInternalOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateDatabaseServerInternalParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createDatabaseServerInternal",
		Method:             "POST",
		PathPattern:        "/v4/databaseservers/internal/managed",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateDatabaseServerInternalReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateDatabaseServerInternalOK), nil

}

/*
DeleteDatabaseServerByCrn terminates and or deregister a database server by c r n

Terminates and/or deregisters a database server by its CRN.
*/
func (a *Client) DeleteDatabaseServerByCrn(params *DeleteDatabaseServerByCrnParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteDatabaseServerByCrnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDatabaseServerByCrnParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteDatabaseServerByCrn",
		Method:             "DELETE",
		PathPattern:        "/v4/databaseservers/{crn}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteDatabaseServerByCrnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteDatabaseServerByCrnOK), nil

}

/*
DeleteDatabaseServerByName terminates and or deregister a database server by name

Terminates and/or deregisters a database server by its name.
*/
func (a *Client) DeleteDatabaseServerByName(params *DeleteDatabaseServerByNameParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteDatabaseServerByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteDatabaseServerByNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteDatabaseServerByName",
		Method:             "DELETE",
		PathPattern:        "/v4/databaseservers/name/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteDatabaseServerByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteDatabaseServerByNameOK), nil

}

/*
DeleteMultipleDatabaseServersByCrn terminates and or deregister multiple database servers by c r n

Terminates and/or deregisters multiple database servers, each by CRN.
*/
func (a *Client) DeleteMultipleDatabaseServersByCrn(params *DeleteMultipleDatabaseServersByCrnParams, authInfo runtime.ClientAuthInfoWriter) (*DeleteMultipleDatabaseServersByCrnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMultipleDatabaseServersByCrnParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteMultipleDatabaseServersByCrn",
		Method:             "DELETE",
		PathPattern:        "/v4/databaseservers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMultipleDatabaseServersByCrnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DeleteMultipleDatabaseServersByCrnOK), nil

}

/*
GetDatabaseServerByCrn gets a database server by c r n

Gets information on a database server by its CRN.
*/
func (a *Client) GetDatabaseServerByCrn(params *GetDatabaseServerByCrnParams, authInfo runtime.ClientAuthInfoWriter) (*GetDatabaseServerByCrnOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDatabaseServerByCrnParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getDatabaseServerByCrn",
		Method:             "GET",
		PathPattern:        "/v4/databaseservers/{crn}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDatabaseServerByCrnReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDatabaseServerByCrnOK), nil

}

/*
GetDatabaseServerByName gets a database server by name

Gets information on a database server by its name.
*/
func (a *Client) GetDatabaseServerByName(params *GetDatabaseServerByNameParams, authInfo runtime.ClientAuthInfoWriter) (*GetDatabaseServerByNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetDatabaseServerByNameParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getDatabaseServerByName",
		Method:             "GET",
		PathPattern:        "/v4/databaseservers/name/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetDatabaseServerByNameReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetDatabaseServerByNameOK), nil

}

/*
ListDatabaseServers lists database servers

Lists all database servers that are known, either because they were registered or because this service created them.
*/
func (a *Client) ListDatabaseServers(params *ListDatabaseServersParams, authInfo runtime.ClientAuthInfoWriter) (*ListDatabaseServersOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewListDatabaseServersParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "listDatabaseServers",
		Method:             "GET",
		PathPattern:        "/v4/databaseservers",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ListDatabaseServersReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ListDatabaseServersOK), nil

}

/*
RegisterDatabaseServer registers a database server

Registers an existing database server.
*/
func (a *Client) RegisterDatabaseServer(params *RegisterDatabaseServerParams, authInfo runtime.ClientAuthInfoWriter) (*RegisterDatabaseServerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRegisterDatabaseServerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "registerDatabaseServer",
		Method:             "POST",
		PathPattern:        "/v4/databaseservers/register",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &RegisterDatabaseServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RegisterDatabaseServerOK), nil

}

/*
ReleaseManagedDatabaseServer releases management of a service managed database server

Releases management of a service-managed database server. Resource tracking information is discarded,  but the server remains registered as user-managed.
*/
func (a *Client) ReleaseManagedDatabaseServer(params *ReleaseManagedDatabaseServerParams, authInfo runtime.ClientAuthInfoWriter) (*ReleaseManagedDatabaseServerOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewReleaseManagedDatabaseServerParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "releaseManagedDatabaseServer",
		Method:             "PUT",
		PathPattern:        "/v4/databaseservers/{crn}/release",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ReleaseManagedDatabaseServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ReleaseManagedDatabaseServerOK), nil

}

/*
StartDatabaseServer starts database server

Start a previosly stopped database server.
*/
func (a *Client) StartDatabaseServer(params *StartDatabaseServerParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStartDatabaseServerParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "startDatabaseServer",
		Method:             "PUT",
		PathPattern:        "/v4/databaseservers/{crn}/start",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StartDatabaseServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
StopDatabaseServer stops database server

Stop a running database server.
*/
func (a *Client) StopDatabaseServer(params *StopDatabaseServerParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStopDatabaseServerParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "stopDatabaseServer",
		Method:             "PUT",
		PathPattern:        "/v4/databaseservers/{crn}/stop",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{""},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &StopDatabaseServerReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
TestDatabaseServerConnection tests database server connectivity

Tests connectivity to a database. Use this to verify access to the database server from this service, and also to verify authentication credentials.
*/
func (a *Client) TestDatabaseServerConnection(params *TestDatabaseServerConnectionParams, authInfo runtime.ClientAuthInfoWriter) (*TestDatabaseServerConnectionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewTestDatabaseServerConnectionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "testDatabaseServerConnection",
		Method:             "POST",
		PathPattern:        "/v4/databaseservers/test",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &TestDatabaseServerConnectionReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*TestDatabaseServerConnectionOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
