/*
Redbeams API

API for working with databases and database servers

API version: 2.66.0-b41-1-ge11bb40
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// DatabaseServersApiService DatabaseServersApi service
type DatabaseServersApiService service

type ApiCreateDatabaseOnServerRequest struct {
	ctx                     context.Context
	ApiService              *DatabaseServersApiService
	createDatabaseV4Request *CreateDatabaseV4Request
}

// Request for creating a new database on a registered database server
func (r ApiCreateDatabaseOnServerRequest) CreateDatabaseV4Request(createDatabaseV4Request CreateDatabaseV4Request) ApiCreateDatabaseOnServerRequest {
	r.createDatabaseV4Request = &createDatabaseV4Request
	return r
}

func (r ApiCreateDatabaseOnServerRequest) Execute() (*CreateDatabaseV4Response, *http.Response, error) {
	return r.ApiService.CreateDatabaseOnServerExecute(r)
}

/*
CreateDatabaseOnServer create a database on an existing database server

Creates a new database on a database server. The database starts out empty. A new user with credentials separate from the database server's administrative user is also created, with full rights to the new database.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateDatabaseOnServerRequest
*/
func (a *DatabaseServersApiService) CreateDatabaseOnServer(ctx context.Context) ApiCreateDatabaseOnServerRequest {
	return ApiCreateDatabaseOnServerRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return CreateDatabaseV4Response
func (a *DatabaseServersApiService) CreateDatabaseOnServerExecute(r ApiCreateDatabaseOnServerRequest) (*CreateDatabaseV4Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateDatabaseV4Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.CreateDatabaseOnServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/createDatabase"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createDatabaseV4Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v CreateDatabaseV4Response
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDatabaseServerRequest struct {
	ctx                             context.Context
	ApiService                      *DatabaseServersApiService
	allocateDatabaseServerV4Request *AllocateDatabaseServerV4Request
}

// Request for allocating a new database server in a provider
func (r ApiCreateDatabaseServerRequest) AllocateDatabaseServerV4Request(allocateDatabaseServerV4Request AllocateDatabaseServerV4Request) ApiCreateDatabaseServerRequest {
	r.allocateDatabaseServerV4Request = &allocateDatabaseServerV4Request
	return r
}

func (r ApiCreateDatabaseServerRequest) Execute() (*DatabaseServerStatusV4Response, *http.Response, error) {
	return r.ApiService.CreateDatabaseServerExecute(r)
}

/*
CreateDatabaseServer create and register a database server in a cloud provider

Creates a new database server. The database server starts out with only default databases.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateDatabaseServerRequest
*/
func (a *DatabaseServersApiService) CreateDatabaseServer(ctx context.Context) ApiCreateDatabaseServerRequest {
	return ApiCreateDatabaseServerRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DatabaseServerStatusV4Response
func (a *DatabaseServersApiService) CreateDatabaseServerExecute(r ApiCreateDatabaseServerRequest) (*DatabaseServerStatusV4Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DatabaseServerStatusV4Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.CreateDatabaseServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/managed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.allocateDatabaseServerV4Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DatabaseServerStatusV4Response
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDatabaseServerInternalRequest struct {
	ctx                             context.Context
	ApiService                      *DatabaseServersApiService
	initiatorUserCrn                *string
	allocateDatabaseServerV4Request *AllocateDatabaseServerV4Request
}

func (r ApiCreateDatabaseServerInternalRequest) InitiatorUserCrn(initiatorUserCrn string) ApiCreateDatabaseServerInternalRequest {
	r.initiatorUserCrn = &initiatorUserCrn
	return r
}

// Request for allocating a new database server in a provider
func (r ApiCreateDatabaseServerInternalRequest) AllocateDatabaseServerV4Request(allocateDatabaseServerV4Request AllocateDatabaseServerV4Request) ApiCreateDatabaseServerInternalRequest {
	r.allocateDatabaseServerV4Request = &allocateDatabaseServerV4Request
	return r
}

func (r ApiCreateDatabaseServerInternalRequest) Execute() (*DatabaseServerStatusV4Response, *http.Response, error) {
	return r.ApiService.CreateDatabaseServerInternalExecute(r)
}

/*
CreateDatabaseServerInternal create and register a database server in a cloud provider with internal actor

Creates a new database server. The database server starts out with only default databases.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateDatabaseServerInternalRequest
*/
func (a *DatabaseServersApiService) CreateDatabaseServerInternal(ctx context.Context) ApiCreateDatabaseServerInternalRequest {
	return ApiCreateDatabaseServerInternalRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DatabaseServerStatusV4Response
func (a *DatabaseServersApiService) CreateDatabaseServerInternalExecute(r ApiCreateDatabaseServerInternalRequest) (*DatabaseServerStatusV4Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DatabaseServerStatusV4Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.CreateDatabaseServerInternal")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/internal/managed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.initiatorUserCrn != nil {
		parameterAddToQuery(localVarQueryParams, "initiatorUserCrn", r.initiatorUserCrn, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.allocateDatabaseServerV4Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DatabaseServerStatusV4Response
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDatabaseServerByCrnRequest struct {
	ctx        context.Context
	ApiService *DatabaseServersApiService
	crn        string
	force      *bool
}

func (r ApiDeleteDatabaseServerByCrnRequest) Force(force bool) ApiDeleteDatabaseServerByCrnRequest {
	r.force = &force
	return r
}

func (r ApiDeleteDatabaseServerByCrnRequest) Execute() (*DatabaseServerV4Response, *http.Response, error) {
	return r.ApiService.DeleteDatabaseServerByCrnExecute(r)
}

/*
DeleteDatabaseServerByCrn terminate and/or deregister a database server by CRN

Terminates and/or deregisters a database server by its CRN.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param crn CRN of the database server
	@return ApiDeleteDatabaseServerByCrnRequest
*/
func (a *DatabaseServersApiService) DeleteDatabaseServerByCrn(ctx context.Context, crn string) ApiDeleteDatabaseServerByCrnRequest {
	return ApiDeleteDatabaseServerByCrnRequest{
		ApiService: a,
		ctx:        ctx,
		crn:        crn,
	}
}

// Execute executes the request
//
//	@return DatabaseServerV4Response
func (a *DatabaseServersApiService) DeleteDatabaseServerByCrnExecute(r ApiDeleteDatabaseServerByCrnRequest) (*DatabaseServerV4Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DatabaseServerV4Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.DeleteDatabaseServerByCrn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/{crn}"
	localVarPath = strings.Replace(localVarPath, "{"+"crn"+"}", url.PathEscape(parameterValueToString(r.crn, "crn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToQuery(localVarQueryParams, "force", r.force, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DatabaseServerV4Response
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDatabaseServerByNameRequest struct {
	ctx            context.Context
	ApiService     *DatabaseServersApiService
	environmentCrn *string
	name           string
	force          *bool
}

// CRN of the environment of the database server(s)
func (r ApiDeleteDatabaseServerByNameRequest) EnvironmentCrn(environmentCrn string) ApiDeleteDatabaseServerByNameRequest {
	r.environmentCrn = &environmentCrn
	return r
}

func (r ApiDeleteDatabaseServerByNameRequest) Force(force bool) ApiDeleteDatabaseServerByNameRequest {
	r.force = &force
	return r
}

func (r ApiDeleteDatabaseServerByNameRequest) Execute() (*DatabaseServerV4Response, *http.Response, error) {
	return r.ApiService.DeleteDatabaseServerByNameExecute(r)
}

/*
DeleteDatabaseServerByName terminate and/or deregister a database server by name

Terminates and/or deregisters a database server by its name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of the database server
	@return ApiDeleteDatabaseServerByNameRequest
*/
func (a *DatabaseServersApiService) DeleteDatabaseServerByName(ctx context.Context, name string) ApiDeleteDatabaseServerByNameRequest {
	return ApiDeleteDatabaseServerByNameRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return DatabaseServerV4Response
func (a *DatabaseServersApiService) DeleteDatabaseServerByNameExecute(r ApiDeleteDatabaseServerByNameRequest) (*DatabaseServerV4Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DatabaseServerV4Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.DeleteDatabaseServerByName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/name/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.environmentCrn == nil {
		return localVarReturnValue, nil, reportError("environmentCrn is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "environmentCrn", r.environmentCrn, "")
	if r.force != nil {
		parameterAddToQuery(localVarQueryParams, "force", r.force, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DatabaseServerV4Response
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMultipleDatabaseServersByCrnRequest struct {
	ctx         context.Context
	ApiService  *DatabaseServersApiService
	force       *bool
	requestBody *[]string
}

func (r ApiDeleteMultipleDatabaseServersByCrnRequest) Force(force bool) ApiDeleteMultipleDatabaseServersByCrnRequest {
	r.force = &force
	return r
}

// CRNs of the database servers
func (r ApiDeleteMultipleDatabaseServersByCrnRequest) RequestBody(requestBody []string) ApiDeleteMultipleDatabaseServersByCrnRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiDeleteMultipleDatabaseServersByCrnRequest) Execute() (*DatabaseServerV4Responses, *http.Response, error) {
	return r.ApiService.DeleteMultipleDatabaseServersByCrnExecute(r)
}

/*
DeleteMultipleDatabaseServersByCrn terminate and/or deregister multiple database servers by CRN

Terminates and/or deregisters multiple database servers, each by CRN.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteMultipleDatabaseServersByCrnRequest
*/
func (a *DatabaseServersApiService) DeleteMultipleDatabaseServersByCrn(ctx context.Context) ApiDeleteMultipleDatabaseServersByCrnRequest {
	return ApiDeleteMultipleDatabaseServersByCrnRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DatabaseServerV4Responses
func (a *DatabaseServersApiService) DeleteMultipleDatabaseServersByCrnExecute(r ApiDeleteMultipleDatabaseServersByCrnRequest) (*DatabaseServerV4Responses, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DatabaseServerV4Responses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.DeleteMultipleDatabaseServersByCrn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToQuery(localVarQueryParams, "force", r.force, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DatabaseServerV4Responses
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabaseServerByClusterCrnRequest struct {
	ctx            context.Context
	ApiService     *DatabaseServersApiService
	environmentCrn *string
	clusterCrn     string
}

// CRN of the environment of the database server(s)
func (r ApiGetDatabaseServerByClusterCrnRequest) EnvironmentCrn(environmentCrn string) ApiGetDatabaseServerByClusterCrnRequest {
	r.environmentCrn = &environmentCrn
	return r
}

func (r ApiGetDatabaseServerByClusterCrnRequest) Execute() (*DatabaseServerV4Response, *http.Response, error) {
	return r.ApiService.GetDatabaseServerByClusterCrnExecute(r)
}

/*
GetDatabaseServerByClusterCrn get a database server by cluster CRN

Gets information on a database server by cluster CRN

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param clusterCrn CRN of cluster of the database server
	@return ApiGetDatabaseServerByClusterCrnRequest
*/
func (a *DatabaseServersApiService) GetDatabaseServerByClusterCrn(ctx context.Context, clusterCrn string) ApiGetDatabaseServerByClusterCrnRequest {
	return ApiGetDatabaseServerByClusterCrnRequest{
		ApiService: a,
		ctx:        ctx,
		clusterCrn: clusterCrn,
	}
}

// Execute executes the request
//
//	@return DatabaseServerV4Response
func (a *DatabaseServersApiService) GetDatabaseServerByClusterCrnExecute(r ApiGetDatabaseServerByClusterCrnRequest) (*DatabaseServerV4Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DatabaseServerV4Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.GetDatabaseServerByClusterCrn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/clusterCrn/{clusterCrn}"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterCrn"+"}", url.PathEscape(parameterValueToString(r.clusterCrn, "clusterCrn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.environmentCrn == nil {
		return localVarReturnValue, nil, reportError("environmentCrn is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "environmentCrn", r.environmentCrn, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DatabaseServerV4Response
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabaseServerByCrnRequest struct {
	ctx        context.Context
	ApiService *DatabaseServersApiService
	crn        string
}

func (r ApiGetDatabaseServerByCrnRequest) Execute() (*DatabaseServerV4Response, *http.Response, error) {
	return r.ApiService.GetDatabaseServerByCrnExecute(r)
}

/*
GetDatabaseServerByCrn get a database server by CRN

Gets information on a database server by its CRN.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param crn CRN of the database server
	@return ApiGetDatabaseServerByCrnRequest
*/
func (a *DatabaseServersApiService) GetDatabaseServerByCrn(ctx context.Context, crn string) ApiGetDatabaseServerByCrnRequest {
	return ApiGetDatabaseServerByCrnRequest{
		ApiService: a,
		ctx:        ctx,
		crn:        crn,
	}
}

// Execute executes the request
//
//	@return DatabaseServerV4Response
func (a *DatabaseServersApiService) GetDatabaseServerByCrnExecute(r ApiGetDatabaseServerByCrnRequest) (*DatabaseServerV4Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DatabaseServerV4Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.GetDatabaseServerByCrn")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/{crn}"
	localVarPath = strings.Replace(localVarPath, "{"+"crn"+"}", url.PathEscape(parameterValueToString(r.crn, "crn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DatabaseServerV4Response
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDatabaseServerByNameRequest struct {
	ctx            context.Context
	ApiService     *DatabaseServersApiService
	environmentCrn *string
	name           string
}

// CRN of the environment of the database server(s)
func (r ApiGetDatabaseServerByNameRequest) EnvironmentCrn(environmentCrn string) ApiGetDatabaseServerByNameRequest {
	r.environmentCrn = &environmentCrn
	return r
}

func (r ApiGetDatabaseServerByNameRequest) Execute() (*DatabaseServerV4Response, *http.Response, error) {
	return r.ApiService.GetDatabaseServerByNameExecute(r)
}

/*
GetDatabaseServerByName get a database server by name

Gets information on a database server by its name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Name of the database server
	@return ApiGetDatabaseServerByNameRequest
*/
func (a *DatabaseServersApiService) GetDatabaseServerByName(ctx context.Context, name string) ApiGetDatabaseServerByNameRequest {
	return ApiGetDatabaseServerByNameRequest{
		ApiService: a,
		ctx:        ctx,
		name:       name,
	}
}

// Execute executes the request
//
//	@return DatabaseServerV4Response
func (a *DatabaseServersApiService) GetDatabaseServerByNameExecute(r ApiGetDatabaseServerByNameRequest) (*DatabaseServerV4Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DatabaseServerV4Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.GetDatabaseServerByName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/name/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.environmentCrn == nil {
		return localVarReturnValue, nil, reportError("environmentCrn is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "environmentCrn", r.environmentCrn, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DatabaseServerV4Response
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsedSubnetsByEnvironmentRequest struct {
	ctx            context.Context
	ApiService     *DatabaseServersApiService
	environmentCrn *string
}

func (r ApiGetUsedSubnetsByEnvironmentRequest) EnvironmentCrn(environmentCrn string) ApiGetUsedSubnetsByEnvironmentRequest {
	r.environmentCrn = &environmentCrn
	return r
}

func (r ApiGetUsedSubnetsByEnvironmentRequest) Execute() (*UsedSubnetsByEnvironmentResponse, *http.Response, error) {
	return r.ApiService.GetUsedSubnetsByEnvironmentExecute(r)
}

/*
GetUsedSubnetsByEnvironment list the used subnets by the given Environment resource CRN

List the used subnets by the given Environment resource CRN

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUsedSubnetsByEnvironmentRequest
*/
func (a *DatabaseServersApiService) GetUsedSubnetsByEnvironment(ctx context.Context) ApiGetUsedSubnetsByEnvironmentRequest {
	return ApiGetUsedSubnetsByEnvironmentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return UsedSubnetsByEnvironmentResponse
func (a *DatabaseServersApiService) GetUsedSubnetsByEnvironmentExecute(r ApiGetUsedSubnetsByEnvironmentRequest) (*UsedSubnetsByEnvironmentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UsedSubnetsByEnvironmentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.GetUsedSubnetsByEnvironment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/internal/used_subnets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.environmentCrn != nil {
		parameterAddToQuery(localVarQueryParams, "environmentCrn", r.environmentCrn, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v UsedSubnetsByEnvironmentResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDatabaseServersRequest struct {
	ctx            context.Context
	ApiService     *DatabaseServersApiService
	environmentCrn *string
}

// CRN of the environment of the database server(s)
func (r ApiListDatabaseServersRequest) EnvironmentCrn(environmentCrn string) ApiListDatabaseServersRequest {
	r.environmentCrn = &environmentCrn
	return r
}

func (r ApiListDatabaseServersRequest) Execute() (*DatabaseServerV4Responses, *http.Response, error) {
	return r.ApiService.ListDatabaseServersExecute(r)
}

/*
ListDatabaseServers list database servers

Lists all database servers that are known, either because they were registered or because this service created them.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListDatabaseServersRequest
*/
func (a *DatabaseServersApiService) ListDatabaseServers(ctx context.Context) ApiListDatabaseServersRequest {
	return ApiListDatabaseServersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DatabaseServerV4Responses
func (a *DatabaseServersApiService) ListDatabaseServersExecute(r ApiListDatabaseServersRequest) (*DatabaseServerV4Responses, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DatabaseServerV4Responses
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.ListDatabaseServers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.environmentCrn == nil {
		return localVarReturnValue, nil, reportError("environmentCrn is required and must be specified")
	}

	parameterAddToQuery(localVarQueryParams, "environmentCrn", r.environmentCrn, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DatabaseServerV4Responses
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRegisterDatabaseServerRequest struct {
	ctx                     context.Context
	ApiService              *DatabaseServersApiService
	databaseServerV4Request *DatabaseServerV4Request
}

// Request containing information about a database server to be registered
func (r ApiRegisterDatabaseServerRequest) DatabaseServerV4Request(databaseServerV4Request DatabaseServerV4Request) ApiRegisterDatabaseServerRequest {
	r.databaseServerV4Request = &databaseServerV4Request
	return r
}

func (r ApiRegisterDatabaseServerRequest) Execute() (*DatabaseServerV4Response, *http.Response, error) {
	return r.ApiService.RegisterDatabaseServerExecute(r)
}

/*
RegisterDatabaseServer register a database server

Registers an existing database server.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRegisterDatabaseServerRequest
*/
func (a *DatabaseServersApiService) RegisterDatabaseServer(ctx context.Context) ApiRegisterDatabaseServerRequest {
	return ApiRegisterDatabaseServerRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DatabaseServerV4Response
func (a *DatabaseServersApiService) RegisterDatabaseServerExecute(r ApiRegisterDatabaseServerRequest) (*DatabaseServerV4Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DatabaseServerV4Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.RegisterDatabaseServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/register"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.databaseServerV4Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DatabaseServerV4Response
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReleaseManagedDatabaseServerRequest struct {
	ctx        context.Context
	ApiService *DatabaseServersApiService
	crn        string
}

func (r ApiReleaseManagedDatabaseServerRequest) Execute() (*DatabaseServerV4Response, *http.Response, error) {
	return r.ApiService.ReleaseManagedDatabaseServerExecute(r)
}

/*
ReleaseManagedDatabaseServer release management of a service-managed database server

Releases management of a service-managed database server. Resource tracking information is discarded,  but the server remains registered as user-managed.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param crn CRN of the database server
	@return ApiReleaseManagedDatabaseServerRequest
*/
func (a *DatabaseServersApiService) ReleaseManagedDatabaseServer(ctx context.Context, crn string) ApiReleaseManagedDatabaseServerRequest {
	return ApiReleaseManagedDatabaseServerRequest{
		ApiService: a,
		ctx:        ctx,
		crn:        crn,
	}
}

// Execute executes the request
//
//	@return DatabaseServerV4Response
func (a *DatabaseServersApiService) ReleaseManagedDatabaseServerExecute(r ApiReleaseManagedDatabaseServerRequest) (*DatabaseServerV4Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DatabaseServerV4Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.ReleaseManagedDatabaseServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/{crn}/release"
	localVarPath = strings.Replace(localVarPath, "{"+"crn"+"}", url.PathEscape(parameterValueToString(r.crn, "crn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DatabaseServerV4Response
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartDatabaseServerRequest struct {
	ctx        context.Context
	ApiService *DatabaseServersApiService
	crn        string
}

func (r ApiStartDatabaseServerRequest) Execute() (*http.Response, error) {
	return r.ApiService.StartDatabaseServerExecute(r)
}

/*
StartDatabaseServer start database server

Start a previosly stopped database server.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param crn CRN of the database server
	@return ApiStartDatabaseServerRequest
*/
func (a *DatabaseServersApiService) StartDatabaseServer(ctx context.Context, crn string) ApiStartDatabaseServerRequest {
	return ApiStartDatabaseServerRequest{
		ApiService: a,
		ctx:        ctx,
		crn:        crn,
	}
}

// Execute executes the request
func (a *DatabaseServersApiService) StartDatabaseServerExecute(r ApiStartDatabaseServerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.StartDatabaseServer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/{crn}/start"
	localVarPath = strings.Replace(localVarPath, "{"+"crn"+"}", url.PathEscape(parameterValueToString(r.crn, "crn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiStopDatabaseServerRequest struct {
	ctx        context.Context
	ApiService *DatabaseServersApiService
	crn        string
}

func (r ApiStopDatabaseServerRequest) Execute() (*http.Response, error) {
	return r.ApiService.StopDatabaseServerExecute(r)
}

/*
StopDatabaseServer stop database server

Stop a running database server.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param crn CRN of the database server
	@return ApiStopDatabaseServerRequest
*/
func (a *DatabaseServersApiService) StopDatabaseServer(ctx context.Context, crn string) ApiStopDatabaseServerRequest {
	return ApiStopDatabaseServerRequest{
		ApiService: a,
		ctx:        ctx,
		crn:        crn,
	}
}

// Execute executes the request
func (a *DatabaseServersApiService) StopDatabaseServerExecute(r ApiStopDatabaseServerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.StopDatabaseServer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/{crn}/stop"
	localVarPath = strings.Replace(localVarPath, "{"+"crn"+"}", url.PathEscape(parameterValueToString(r.crn, "crn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiTestDatabaseServerConnectionRequest struct {
	ctx                         context.Context
	ApiService                  *DatabaseServersApiService
	databaseServerTestV4Request *DatabaseServerTestV4Request
}

// Request for testing connectivity to a database server
func (r ApiTestDatabaseServerConnectionRequest) DatabaseServerTestV4Request(databaseServerTestV4Request DatabaseServerTestV4Request) ApiTestDatabaseServerConnectionRequest {
	r.databaseServerTestV4Request = &databaseServerTestV4Request
	return r
}

func (r ApiTestDatabaseServerConnectionRequest) Execute() (*DatabaseServerTestV4Response, *http.Response, error) {
	return r.ApiService.TestDatabaseServerConnectionExecute(r)
}

/*
TestDatabaseServerConnection test database server connectivity

Tests connectivity to a database. Use this to verify access to the database server from this service, and also to verify authentication credentials.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestDatabaseServerConnectionRequest
*/
func (a *DatabaseServersApiService) TestDatabaseServerConnection(ctx context.Context) ApiTestDatabaseServerConnectionRequest {
	return ApiTestDatabaseServerConnectionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return DatabaseServerTestV4Response
func (a *DatabaseServersApiService) TestDatabaseServerConnectionExecute(r ApiTestDatabaseServerConnectionRequest) (*DatabaseServerTestV4Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DatabaseServerTestV4Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.TestDatabaseServerConnection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.databaseServerTestV4Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v DatabaseServerTestV4Response
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateClusterCrnRequest struct {
	ctx               context.Context
	ApiService        *DatabaseServersApiService
	environmentCrn    *string
	currentClusterCrn *string
	newClusterCrn     *string
	initiatorUserCrn  *string
}

func (r ApiUpdateClusterCrnRequest) EnvironmentCrn(environmentCrn string) ApiUpdateClusterCrnRequest {
	r.environmentCrn = &environmentCrn
	return r
}

func (r ApiUpdateClusterCrnRequest) CurrentClusterCrn(currentClusterCrn string) ApiUpdateClusterCrnRequest {
	r.currentClusterCrn = &currentClusterCrn
	return r
}

func (r ApiUpdateClusterCrnRequest) NewClusterCrn(newClusterCrn string) ApiUpdateClusterCrnRequest {
	r.newClusterCrn = &newClusterCrn
	return r
}

func (r ApiUpdateClusterCrnRequest) InitiatorUserCrn(initiatorUserCrn string) ApiUpdateClusterCrnRequest {
	r.initiatorUserCrn = &initiatorUserCrn
	return r
}

func (r ApiUpdateClusterCrnRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateClusterCrnExecute(r)
}

/*
UpdateClusterCrn Update the cluster crn associated with the database

Updates the cluster crn associated with the database

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateClusterCrnRequest
*/
func (a *DatabaseServersApiService) UpdateClusterCrn(ctx context.Context) ApiUpdateClusterCrnRequest {
	return ApiUpdateClusterCrnRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DatabaseServersApiService) UpdateClusterCrnExecute(r ApiUpdateClusterCrnRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.UpdateClusterCrn")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/updateclustercrn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.environmentCrn != nil {
		parameterAddToQuery(localVarQueryParams, "environmentCrn", r.environmentCrn, "")
	}
	if r.currentClusterCrn != nil {
		parameterAddToQuery(localVarQueryParams, "currentClusterCrn", r.currentClusterCrn, "")
	}
	if r.newClusterCrn != nil {
		parameterAddToQuery(localVarQueryParams, "newClusterCrn", r.newClusterCrn, "")
	}
	if r.initiatorUserCrn != nil {
		parameterAddToQuery(localVarQueryParams, "initiatorUserCrn", r.initiatorUserCrn, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpgradeDatabaseServerRequest struct {
	ctx                            context.Context
	ApiService                     *DatabaseServersApiService
	crn                            string
	upgradeDatabaseServerV4Request *UpgradeDatabaseServerV4Request
}

// Request for upgrading a database server in a provider to a higher major version
func (r ApiUpgradeDatabaseServerRequest) UpgradeDatabaseServerV4Request(upgradeDatabaseServerV4Request UpgradeDatabaseServerV4Request) ApiUpgradeDatabaseServerRequest {
	r.upgradeDatabaseServerV4Request = &upgradeDatabaseServerV4Request
	return r
}

func (r ApiUpgradeDatabaseServerRequest) Execute() (*UpgradeDatabaseServerV4Response, *http.Response, error) {
	return r.ApiService.UpgradeDatabaseServerExecute(r)
}

/*
UpgradeDatabaseServer upgrade a database server in a cloud provider to a higher major version

Upgrades a database server to a higher major version.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param crn CRN of the database server
	@return ApiUpgradeDatabaseServerRequest
*/
func (a *DatabaseServersApiService) UpgradeDatabaseServer(ctx context.Context, crn string) ApiUpgradeDatabaseServerRequest {
	return ApiUpgradeDatabaseServerRequest{
		ApiService: a,
		ctx:        ctx,
		crn:        crn,
	}
}

// Execute executes the request
//
//	@return UpgradeDatabaseServerV4Response
func (a *DatabaseServersApiService) UpgradeDatabaseServerExecute(r ApiUpgradeDatabaseServerRequest) (*UpgradeDatabaseServerV4Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpgradeDatabaseServerV4Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.UpgradeDatabaseServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/{crn}/upgrade"
	localVarPath = strings.Replace(localVarPath, "{"+"crn"+"}", url.PathEscape(parameterValueToString(r.crn, "crn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.upgradeDatabaseServerV4Request == nil {
		return localVarReturnValue, nil, reportError("upgradeDatabaseServerV4Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.upgradeDatabaseServerV4Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v UpgradeDatabaseServerV4Response
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateUpgradeDatabaseServerRequest struct {
	ctx                            context.Context
	ApiService                     *DatabaseServersApiService
	crn                            string
	upgradeDatabaseServerV4Request *UpgradeDatabaseServerV4Request
}

// Request for upgrading a database server in a provider to a higher major version
func (r ApiValidateUpgradeDatabaseServerRequest) UpgradeDatabaseServerV4Request(upgradeDatabaseServerV4Request UpgradeDatabaseServerV4Request) ApiValidateUpgradeDatabaseServerRequest {
	r.upgradeDatabaseServerV4Request = &upgradeDatabaseServerV4Request
	return r
}

func (r ApiValidateUpgradeDatabaseServerRequest) Execute() (*UpgradeDatabaseServerV4Response, *http.Response, error) {
	return r.ApiService.ValidateUpgradeDatabaseServerExecute(r)
}

/*
ValidateUpgradeDatabaseServer validate if upgrade is possible on the database server in a cloud provider to a higher major version

Validates if upgrade is possible on the database server to a higher major version.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param crn CRN of the database server
	@return ApiValidateUpgradeDatabaseServerRequest
*/
func (a *DatabaseServersApiService) ValidateUpgradeDatabaseServer(ctx context.Context, crn string) ApiValidateUpgradeDatabaseServerRequest {
	return ApiValidateUpgradeDatabaseServerRequest{
		ApiService: a,
		ctx:        ctx,
		crn:        crn,
	}
}

// Execute executes the request
//
//	@return UpgradeDatabaseServerV4Response
func (a *DatabaseServersApiService) ValidateUpgradeDatabaseServerExecute(r ApiValidateUpgradeDatabaseServerRequest) (*UpgradeDatabaseServerV4Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *UpgradeDatabaseServerV4Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DatabaseServersApiService.ValidateUpgradeDatabaseServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v4/databaseservers/{crn}/validate_upgrade"
	localVarPath = strings.Replace(localVarPath, "{"+"crn"+"}", url.PathEscape(parameterValueToString(r.crn, "crn")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.upgradeDatabaseServerV4Request == nil {
		return localVarReturnValue, nil, reportError("upgradeDatabaseServerV4Request is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.upgradeDatabaseServerV4Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v UpgradeDatabaseServerV4Response
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
