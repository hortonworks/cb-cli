// Code generated by go-swagger; DO NOT EDIT.

package v1alerts

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new v1alerts API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for v1alerts API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
CreateMetricAlerts creates alert which metric based

Auto-scaling supports two Alert types: metric and time based. Metric based alerts are using the default (or custom) Ambari metrics. These metrics have a default Threshold value configured in Ambari - nevertheless these thresholds can be configured, changed or altered in Ambari. In order to change the default threshold for a metric please go to Ambari UI and select the Alerts tab and the metric. The values can be changed in the Threshold section.
*/
func (a *Client) CreateMetricAlerts(params *CreateMetricAlertsParams) (*CreateMetricAlertsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateMetricAlertsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createMetricAlerts",
		Method:             "POST",
		PathPattern:        "/v1/clusters/{clusterId}/alerts/metric",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateMetricAlertsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateMetricAlertsOK), nil

}

/*
CreatePrometheusAlert creates alert which prometheus based

Prometheus based alerts are using Prometheus under the hood.
*/
func (a *Client) CreatePrometheusAlert(params *CreatePrometheusAlertParams) (*CreatePrometheusAlertOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreatePrometheusAlertParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createPrometheusAlert",
		Method:             "POST",
		PathPattern:        "/v1/clusters/{clusterId}/alerts/prometheus",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreatePrometheusAlertReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreatePrometheusAlertOK), nil

}

/*
CreateTimeAlert creates alert which time based

Auto-scaling supports two Alert types: metric and time based. Time based alerts are based on cron expressions and allow alerts to be triggered based on time.
*/
func (a *Client) CreateTimeAlert(params *CreateTimeAlertParams) (*CreateTimeAlertOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateTimeAlertParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "createTimeAlert",
		Method:             "POST",
		PathPattern:        "/v1/clusters/{clusterId}/alerts/time",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateTimeAlertReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateTimeAlertOK), nil

}

/*
DeleteMetricAlarm deletes alert which metric based

Auto-scaling supports two Alert types: metric and time based. Metric based alerts are using the default (or custom) Ambari metrics. These metrics have a default Threshold value configured in Ambari - nevertheless these thresholds can be configured, changed or altered in Ambari. In order to change the default threshold for a metric please go to Ambari UI and select the Alerts tab and the metric. The values can be changed in the Threshold section.
*/
func (a *Client) DeleteMetricAlarm(params *DeleteMetricAlarmParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteMetricAlarmParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteMetricAlarm",
		Method:             "DELETE",
		PathPattern:        "/v1/clusters/{clusterId}/alerts/metric/{alertId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteMetricAlarmReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
DeletePrometheusAlarm deletes alert which prometheus based

Prometheus based alerts are using Prometheus under the hood.
*/
func (a *Client) DeletePrometheusAlarm(params *DeletePrometheusAlarmParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeletePrometheusAlarmParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deletePrometheusAlarm",
		Method:             "DELETE",
		PathPattern:        "/v1/clusters/{clusterId}/alerts/prometheus/{alertId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeletePrometheusAlarmReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
DeleteTimeAlert deletes alert which time based

Auto-scaling supports two Alert types: metric and time based. Time based alerts are based on cron expressions and allow alerts to be triggered based on time.
*/
func (a *Client) DeleteTimeAlert(params *DeleteTimeAlertParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteTimeAlertParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteTimeAlert",
		Method:             "DELETE",
		PathPattern:        "/v1/clusters/{clusterId}/alerts/time/{alertId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteTimeAlertReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetAlertDefinitions retrieves alert definitions

Auto-scaling supports two Alert types: metric and time based. Metric based alerts are using the default (or custom) Ambari metrics. These metrics have a default Threshold value configured in Ambari - nevertheless these thresholds can be configured, changed or altered in Ambari. In order to change the default threshold for a metric please go to Ambari UI and select the Alerts tab and the metric. The values can be changed in the Threshold section.
*/
func (a *Client) GetAlertDefinitions(params *GetAlertDefinitionsParams) (*GetAlertDefinitionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAlertDefinitionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getAlertDefinitions",
		Method:             "GET",
		PathPattern:        "/v1/clusters/{clusterId}/alerts/metric/definitions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetAlertDefinitionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetAlertDefinitionsOK), nil

}

/*
GetMetricAlerts retrieves alert which metric based

Auto-scaling supports two Alert types: metric and time based. Metric based alerts are using the default (or custom) Ambari metrics. These metrics have a default Threshold value configured in Ambari - nevertheless these thresholds can be configured, changed or altered in Ambari. In order to change the default threshold for a metric please go to Ambari UI and select the Alerts tab and the metric. The values can be changed in the Threshold section.
*/
func (a *Client) GetMetricAlerts(params *GetMetricAlertsParams) (*GetMetricAlertsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMetricAlertsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getMetricAlerts",
		Method:             "GET",
		PathPattern:        "/v1/clusters/{clusterId}/alerts/metric",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetMetricAlertsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetMetricAlertsOK), nil

}

/*
GetPrometheusAlerts retrieves alert which prometheus based

Prometheus based alerts are using Prometheus under the hood.
*/
func (a *Client) GetPrometheusAlerts(params *GetPrometheusAlertsParams) (*GetPrometheusAlertsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPrometheusAlertsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPrometheusAlerts",
		Method:             "GET",
		PathPattern:        "/v1/clusters/{clusterId}/alerts/prometheus",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetPrometheusAlertsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPrometheusAlertsOK), nil

}

/*
GetPrometheusDefinitions retrieves alert definitions

retrieve Prometheus alert rule definitions
*/
func (a *Client) GetPrometheusDefinitions(params *GetPrometheusDefinitionsParams) (*GetPrometheusDefinitionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPrometheusDefinitionsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getPrometheusDefinitions",
		Method:             "GET",
		PathPattern:        "/v1/clusters/{clusterId}/alerts/prometheus/definitions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetPrometheusDefinitionsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPrometheusDefinitionsOK), nil

}

/*
GetTimeAlerts retrieves alert which time based

Auto-scaling supports two Alert types: metric and time based. Time based alerts are based on cron expressions and allow alerts to be triggered based on time.
*/
func (a *Client) GetTimeAlerts(params *GetTimeAlertsParams) (*GetTimeAlertsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTimeAlertsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getTimeAlerts",
		Method:             "GET",
		PathPattern:        "/v1/clusters/{clusterId}/alerts/time",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetTimeAlertsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetTimeAlertsOK), nil

}

/*
UpdateMetricAlerts modifies alert which metric based

Auto-scaling supports two Alert types: metric and time based. Metric based alerts are using the default (or custom) Ambari metrics. These metrics have a default Threshold value configured in Ambari - nevertheless these thresholds can be configured, changed or altered in Ambari. In order to change the default threshold for a metric please go to Ambari UI and select the Alerts tab and the metric. The values can be changed in the Threshold section.
*/
func (a *Client) UpdateMetricAlerts(params *UpdateMetricAlertsParams) (*UpdateMetricAlertsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateMetricAlertsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateMetricAlerts",
		Method:             "PUT",
		PathPattern:        "/v1/clusters/{clusterId}/alerts/metric/{alertId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateMetricAlertsReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateMetricAlertsOK), nil

}

/*
UpdatePrometheusAlert modifies alert which prometheus based

Prometheus based alerts are using Prometheus under the hood.
*/
func (a *Client) UpdatePrometheusAlert(params *UpdatePrometheusAlertParams) (*UpdatePrometheusAlertOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdatePrometheusAlertParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updatePrometheusAlert",
		Method:             "PUT",
		PathPattern:        "/v1/clusters/{clusterId}/alerts/prometheus/{alertId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdatePrometheusAlertReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdatePrometheusAlertOK), nil

}

/*
UpdateTimeAlert modifies alert which time based

Auto-scaling supports two Alert types: metric and time based. Time based alerts are based on cron expressions and allow alerts to be triggered based on time.
*/
func (a *Client) UpdateTimeAlert(params *UpdateTimeAlertParams) (*UpdateTimeAlertOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateTimeAlertParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateTimeAlert",
		Method:             "PUT",
		PathPattern:        "/v1/clusters/{clusterId}/alerts/time/{alertId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateTimeAlertReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateTimeAlertOK), nil

}

/*
ValidateCronExpression crons expression validation

Auto-scaling supports two Alert types: metric and time based. Time based alerts are based on cron expressions and allow alerts to be triggered based on time.
*/
func (a *Client) ValidateCronExpression(params *ValidateCronExpressionParams) (*ValidateCronExpressionOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewValidateCronExpressionParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "validateCronExpression",
		Method:             "POST",
		PathPattern:        "/v1/clusters/{clusterId}/alerts/time/validate",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &ValidateCronExpressionReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*ValidateCronExpressionOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
