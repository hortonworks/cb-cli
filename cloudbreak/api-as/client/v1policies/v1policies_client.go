// Code generated by go-swagger; DO NOT EDIT.

package v1policies

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new v1policies API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for v1policies API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
AddScalingPolicy creates policy

Scaling is the ability to increase or decrease the capacity of the Hadoop cluster or application based on an alert. When scaling policies are used, the capacity is automatically increased or decreased according to the conditions defined. Cloudbreak will do the heavy lifting and based on the alerts and the scaling policy linked to them it executes the associated policy. We scaling granularity is at the hostgroup level - thus you have the option to scale services or components only, not the whole cluster.
*/
func (a *Client) AddScalingPolicy(params *AddScalingPolicyParams) (*AddScalingPolicyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAddScalingPolicyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "addScalingPolicy",
		Method:             "POST",
		PathPattern:        "/v1/clusters/{clusterId}/policies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &AddScalingPolicyReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*AddScalingPolicyOK), nil

}

/*
DeleteScalingPolicy deletes policy

Scaling is the ability to increase or decrease the capacity of the Hadoop cluster or application based on an alert. When scaling policies are used, the capacity is automatically increased or decreased according to the conditions defined. Cloudbreak will do the heavy lifting and based on the alerts and the scaling policy linked to them it executes the associated policy. We scaling granularity is at the hostgroup level - thus you have the option to scale services or components only, not the whole cluster.
*/
func (a *Client) DeleteScalingPolicy(params *DeleteScalingPolicyParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteScalingPolicyParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteScalingPolicy",
		Method:             "DELETE",
		PathPattern:        "/v1/clusters/{clusterId}/policies/{policyId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteScalingPolicyReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil

}

/*
GetScalingPolicies retrieves policy

Scaling is the ability to increase or decrease the capacity of the Hadoop cluster or application based on an alert. When scaling policies are used, the capacity is automatically increased or decreased according to the conditions defined. Cloudbreak will do the heavy lifting and based on the alerts and the scaling policy linked to them it executes the associated policy. We scaling granularity is at the hostgroup level - thus you have the option to scale services or components only, not the whole cluster.
*/
func (a *Client) GetScalingPolicies(params *GetScalingPoliciesParams) (*GetScalingPoliciesOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetScalingPoliciesParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getScalingPolicies",
		Method:             "GET",
		PathPattern:        "/v1/clusters/{clusterId}/policies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetScalingPoliciesReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetScalingPoliciesOK), nil

}

/*
UpdateScalingPolicy modifies policy

Scaling is the ability to increase or decrease the capacity of the Hadoop cluster or application based on an alert. When scaling policies are used, the capacity is automatically increased or decreased according to the conditions defined. Cloudbreak will do the heavy lifting and based on the alerts and the scaling policy linked to them it executes the associated policy. We scaling granularity is at the hostgroup level - thus you have the option to scale services or components only, not the whole cluster.
*/
func (a *Client) UpdateScalingPolicy(params *UpdateScalingPolicyParams) (*UpdateScalingPolicyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateScalingPolicyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "updateScalingPolicy",
		Method:             "PUT",
		PathPattern:        "/v1/clusters/{clusterId}/policies/{policyId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateScalingPolicyReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateScalingPolicyOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
