package configurations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-swagger/go-swagger/client"

	strfmt "github.com/go-swagger/go-swagger/strfmt"
)

// New creates a new configurations API client.
func New(transport client.Transport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for configurations API
*/
type Client struct {
	transport client.Transport
	formats   strfmt.Registry
}

/*
GetScalingConfiguration retrieves configuration

An SLA scaling policy can contain multiple alerts. When an alert is triggered a scaling adjustment is applied, however to keep the cluster size within boundaries a cluster size min. and cluster size max. is attached to the cluster - thus a scaling policy can never over or undersize a cluster. Also in order to avoid stressing the cluster we have introduced a cooldown time period (minutes) - though an alert is raised and there is an associated scaling policy, the system will not apply the policy within the configured timeframe. In an SLA scaling policy the triggered rules are applied in order.
*/
func (a *Client) GetScalingConfiguration(params *GetScalingConfigurationParams) (*GetScalingConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetScalingConfigurationParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "getScalingConfiguration",
		Method:             "GET",
		PathPattern:        "/clusters/{clusterId}/configurations/scaling",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetScalingConfigurationReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetScalingConfigurationOK), nil
}

/*
SetScalingConfiguration creates configuration

An SLA scaling policy can contain multiple alerts. When an alert is triggered a scaling adjustment is applied, however to keep the cluster size within boundaries a cluster size min. and cluster size max. is attached to the cluster - thus a scaling policy can never over or undersize a cluster. Also in order to avoid stressing the cluster we have introduced a cooldown time period (minutes) - though an alert is raised and there is an associated scaling policy, the system will not apply the policy within the configured timeframe. In an SLA scaling policy the triggered rules are applied in order.
*/
func (a *Client) SetScalingConfiguration(params *SetScalingConfigurationParams) (*SetScalingConfigurationOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetScalingConfigurationParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "setScalingConfiguration",
		Method:             "POST",
		PathPattern:        "/clusters/{clusterId}/configurations/scaling",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SetScalingConfigurationReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*SetScalingConfigurationOK), nil
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport client.Transport) {
	a.transport = transport
}
