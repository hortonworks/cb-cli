package alerts

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-swagger/go-swagger/client"

	strfmt "github.com/go-swagger/go-swagger/strfmt"
)

// New creates a new alerts API client.
func New(transport client.Transport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for alerts API
*/
type Client struct {
	transport client.Transport
	formats   strfmt.Registry
}

/*
CreateAlerts creates alert which metric based

Auto-scaling supports two Alert types: metric and time based. Metric based alerts are using the default (or custom) Ambari metrics. These metrics have a default Threshold value configured in Ambari - nevertheless these thresholds can be configured, changed or altered in Ambari. In order to change the default threshold for a metric please go to Ambari UI and select the Alerts tab and the metric. The values can be changed in the Threshold section.
*/
func (a *Client) CreateAlerts(params *CreateAlertsParams) (*CreateAlertsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateAlertsParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "createAlerts",
		Method:             "POST",
		PathPattern:        "/clusters/{clusterId}/alerts/metric",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateAlertsReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateAlertsOK), nil
}

/*
CreatePrometheusAlert creates alert which prometheus based

Prometheus based alerts are using Prometheus under the hood.
*/
func (a *Client) CreatePrometheusAlert(params *CreatePrometheusAlertParams) (*CreatePrometheusAlertOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreatePrometheusAlertParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "createPrometheusAlert",
		Method:             "POST",
		PathPattern:        "/clusters/{clusterId}/alerts/prometheus",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreatePrometheusAlertReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreatePrometheusAlertOK), nil
}

/*
CreateTimeAlert creates alert which time based

Auto-scaling supports two Alert types: metric and time based. Time based alerts are based on cron expressions and allow alerts to be triggered based on time.
*/
func (a *Client) CreateTimeAlert(params *CreateTimeAlertParams) (*CreateTimeAlertOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCreateTimeAlertParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "createTimeAlert",
		Method:             "POST",
		PathPattern:        "/clusters/{clusterId}/alerts/time",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &CreateTimeAlertReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*CreateTimeAlertOK), nil
}

/*
DeleteAlarm deletes alert which metric based

Auto-scaling supports two Alert types: metric and time based. Metric based alerts are using the default (or custom) Ambari metrics. These metrics have a default Threshold value configured in Ambari - nevertheless these thresholds can be configured, changed or altered in Ambari. In order to change the default threshold for a metric please go to Ambari UI and select the Alerts tab and the metric. The values can be changed in the Threshold section.
*/
func (a *Client) DeleteAlarm(params *DeleteAlarmParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteAlarmParams()
	}

	_, err := a.transport.Submit(&client.Operation{
		ID:                 "deleteAlarm",
		Method:             "DELETE",
		PathPattern:        "/clusters/{clusterId}/alerts/metric/{alertId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteAlarmReader{formats: a.formats},
	})
	if err != nil {
		return err
	}
	return nil
}

/*
DeletePrometheusAlarm deletes alert which prometheus based

Prometheus based alerts are using Prometheus under the hood.
*/
func (a *Client) DeletePrometheusAlarm(params *DeletePrometheusAlarmParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeletePrometheusAlarmParams()
	}

	_, err := a.transport.Submit(&client.Operation{
		ID:                 "deletePrometheusAlarm",
		Method:             "DELETE",
		PathPattern:        "/clusters/{clusterId}/alerts/prometheus/{alertId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeletePrometheusAlarmReader{formats: a.formats},
	})
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteTimeAlert deletes alert which time based

Auto-scaling supports two Alert types: metric and time based. Time based alerts are based on cron expressions and allow alerts to be triggered based on time.
*/
func (a *Client) DeleteTimeAlert(params *DeleteTimeAlertParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteTimeAlertParams()
	}

	_, err := a.transport.Submit(&client.Operation{
		ID:                 "deleteTimeAlert",
		Method:             "DELETE",
		PathPattern:        "/clusters/{clusterId}/alerts/time/{alertId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteTimeAlertReader{formats: a.formats},
	})
	if err != nil {
		return err
	}
	return nil
}

/*
GetAlertDefinitions retrieves alert definitions

Auto-scaling supports two Alert types: metric and time based. Metric based alerts are using the default (or custom) Ambari metrics. These metrics have a default Threshold value configured in Ambari - nevertheless these thresholds can be configured, changed or altered in Ambari. In order to change the default threshold for a metric please go to Ambari UI and select the Alerts tab and the metric. The values can be changed in the Threshold section.
*/
func (a *Client) GetAlertDefinitions(params *GetAlertDefinitionsParams) (*GetAlertDefinitionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAlertDefinitionsParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "getAlertDefinitions",
		Method:             "GET",
		PathPattern:        "/clusters/{clusterId}/alerts/metric/definitions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetAlertDefinitionsReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetAlertDefinitionsOK), nil
}

/*
GetAlerts retrieves alert which metric based

Auto-scaling supports two Alert types: metric and time based. Metric based alerts are using the default (or custom) Ambari metrics. These metrics have a default Threshold value configured in Ambari - nevertheless these thresholds can be configured, changed or altered in Ambari. In order to change the default threshold for a metric please go to Ambari UI and select the Alerts tab and the metric. The values can be changed in the Threshold section.
*/
func (a *Client) GetAlerts(params *GetAlertsParams) (*GetAlertsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAlertsParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "getAlerts",
		Method:             "GET",
		PathPattern:        "/clusters/{clusterId}/alerts/metric",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetAlertsReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetAlertsOK), nil
}

/*
GetPrometheusAlerts retrieves alert which prometheus based

Prometheus based alerts are using Prometheus under the hood.
*/
func (a *Client) GetPrometheusAlerts(params *GetPrometheusAlertsParams) (*GetPrometheusAlertsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPrometheusAlertsParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "getPrometheusAlerts",
		Method:             "GET",
		PathPattern:        "/clusters/{clusterId}/alerts/prometheus",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetPrometheusAlertsReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPrometheusAlertsOK), nil
}

/*
GetPrometheusDefinitions retrieves alert definitions

retrieve Prometheus alert rule definitions
*/
func (a *Client) GetPrometheusDefinitions(params *GetPrometheusDefinitionsParams) (*GetPrometheusDefinitionsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetPrometheusDefinitionsParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "getPrometheusDefinitions",
		Method:             "GET",
		PathPattern:        "/clusters/{clusterId}/alerts/prometheus/definitions",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetPrometheusDefinitionsReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetPrometheusDefinitionsOK), nil
}

/*
GetTimeAlerts retrieves alert which time based

Auto-scaling supports two Alert types: metric and time based. Time based alerts are based on cron expressions and allow alerts to be triggered based on time.
*/
func (a *Client) GetTimeAlerts(params *GetTimeAlertsParams) (*GetTimeAlertsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetTimeAlertsParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "getTimeAlerts",
		Method:             "GET",
		PathPattern:        "/clusters/{clusterId}/alerts/time",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetTimeAlertsReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetTimeAlertsOK), nil
}

/*
SetTimeAlert modifies alert which time based

Auto-scaling supports two Alert types: metric and time based. Time based alerts are based on cron expressions and allow alerts to be triggered based on time.
*/
func (a *Client) SetTimeAlert(params *SetTimeAlertParams) (*SetTimeAlertOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetTimeAlertParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "setTimeAlert",
		Method:             "PUT",
		PathPattern:        "/clusters/{clusterId}/alerts/time/{alertId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &SetTimeAlertReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*SetTimeAlertOK), nil
}

/*
UpdateAlerts modifies alert which metric based

Auto-scaling supports two Alert types: metric and time based. Metric based alerts are using the default (or custom) Ambari metrics. These metrics have a default Threshold value configured in Ambari - nevertheless these thresholds can be configured, changed or altered in Ambari. In order to change the default threshold for a metric please go to Ambari UI and select the Alerts tab and the metric. The values can be changed in the Threshold section.
*/
func (a *Client) UpdateAlerts(params *UpdateAlertsParams) (*UpdateAlertsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdateAlertsParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "updateAlerts",
		Method:             "PUT",
		PathPattern:        "/clusters/{clusterId}/alerts/metric/{alertId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdateAlertsReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdateAlertsOK), nil
}

/*
UpdatePrometheusAlert modifies alert which prometheus based

Prometheus based alerts are using Prometheus under the hood.
*/
func (a *Client) UpdatePrometheusAlert(params *UpdatePrometheusAlertParams) (*UpdatePrometheusAlertOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUpdatePrometheusAlertParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "updatePrometheusAlert",
		Method:             "PUT",
		PathPattern:        "/clusters/{clusterId}/alerts/prometheus/{alertId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &UpdatePrometheusAlertReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*UpdatePrometheusAlertOK), nil
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport client.Transport) {
	a.transport = transport
}
