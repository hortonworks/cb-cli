package credentials

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-swagger/go-swagger/client"

	strfmt "github.com/go-swagger/go-swagger/strfmt"
)

// New creates a new credentials API client.
func New(transport client.Transport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for credentials API
*/
type Client struct {
	transport client.Transport
	formats   strfmt.Registry
}

/*
DeleteCredentialsAccountName deletes public owned or private credential by name

Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.
*/
func (a *Client) DeleteCredentialsAccountName(params *DeleteCredentialsAccountNameParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteCredentialsAccountNameParams()
	}

	_, err := a.transport.Submit(&client.Operation{
		ID:                 "DeleteCredentialsAccountName",
		Method:             "DELETE",
		PathPattern:        "/credentials/account/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteCredentialsAccountNameReader{formats: a.formats},
	})
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteCredentialsID deletes credential by id

Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.
*/
func (a *Client) DeleteCredentialsID(params *DeleteCredentialsIDParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteCredentialsIDParams()
	}

	_, err := a.transport.Submit(&client.Operation{
		ID:                 "DeleteCredentialsID",
		Method:             "DELETE",
		PathPattern:        "/credentials/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteCredentialsIDReader{formats: a.formats},
	})
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteCredentialsUserName deletes private credential by name

Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.
*/
func (a *Client) DeleteCredentialsUserName(params *DeleteCredentialsUserNameParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteCredentialsUserNameParams()
	}

	_, err := a.transport.Submit(&client.Operation{
		ID:                 "DeleteCredentialsUserName",
		Method:             "DELETE",
		PathPattern:        "/credentials/user/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteCredentialsUserNameReader{formats: a.formats},
	})
	if err != nil {
		return err
	}
	return nil
}

/*
GetCredentialsAccount retrieves public and private owned credentials

Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.
*/
func (a *Client) GetCredentialsAccount(params *GetCredentialsAccountParams) (*GetCredentialsAccountOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCredentialsAccountParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "GetCredentialsAccount",
		Method:             "GET",
		PathPattern:        "/credentials/account",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetCredentialsAccountReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCredentialsAccountOK), nil
}

/*
GetCredentialsAccountName retrieves a public or private owned credential by name

Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.
*/
func (a *Client) GetCredentialsAccountName(params *GetCredentialsAccountNameParams) (*GetCredentialsAccountNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCredentialsAccountNameParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "GetCredentialsAccountName",
		Method:             "GET",
		PathPattern:        "/credentials/account/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetCredentialsAccountNameReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCredentialsAccountNameOK), nil
}

/*
GetCredentialsID retrieves credential by id

Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.
*/
func (a *Client) GetCredentialsID(params *GetCredentialsIDParams) (*GetCredentialsIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCredentialsIDParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "GetCredentialsID",
		Method:             "GET",
		PathPattern:        "/credentials/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetCredentialsIDReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCredentialsIDOK), nil
}

/*
GetCredentialsUser retrieves private credentials

Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.
*/
func (a *Client) GetCredentialsUser(params *GetCredentialsUserParams) (*GetCredentialsUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCredentialsUserParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "GetCredentialsUser",
		Method:             "GET",
		PathPattern:        "/credentials/user",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetCredentialsUserReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCredentialsUserOK), nil
}

/*
GetCredentialsUserName retrieves a private credential by name

Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.
*/
func (a *Client) GetCredentialsUserName(params *GetCredentialsUserNameParams) (*GetCredentialsUserNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetCredentialsUserNameParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "GetCredentialsUserName",
		Method:             "GET",
		PathPattern:        "/credentials/user/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetCredentialsUserNameReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetCredentialsUserNameOK), nil
}

/*
PostCredentialsAccount creates credential as public resource

Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.
*/
func (a *Client) PostCredentialsAccount(params *PostCredentialsAccountParams) (*PostCredentialsAccountOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostCredentialsAccountParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "PostCredentialsAccount",
		Method:             "POST",
		PathPattern:        "/credentials/account",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostCredentialsAccountReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostCredentialsAccountOK), nil
}

/*
PostCredentialsUser creates credential as private resource

Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.
*/
func (a *Client) PostCredentialsUser(params *PostCredentialsUserParams) (*PostCredentialsUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostCredentialsUserParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "PostCredentialsUser",
		Method:             "POST",
		PathPattern:        "/credentials/user",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostCredentialsUserReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostCredentialsUserOK), nil
}

/*
PrivateInteractiveLogin interactives login

Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.
*/
func (a *Client) PrivateInteractiveLogin(params *PrivateInteractiveLoginParams) (*PrivateInteractiveLoginOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPrivateInteractiveLoginParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "privateInteractiveLogin",
		Method:             "POST",
		PathPattern:        "/credentials/userinteractivelogin",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PrivateInteractiveLoginReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*PrivateInteractiveLoginOK), nil
}

/*
PublicInteractiveLogin interactives login

Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.
*/
func (a *Client) PublicInteractiveLogin(params *PublicInteractiveLoginParams) (*PublicInteractiveLoginOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPublicInteractiveLoginParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "publicInteractiveLogin",
		Method:             "POST",
		PathPattern:        "/credentials/accountinteractivelogin",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PublicInteractiveLoginReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*PublicInteractiveLoginOK), nil
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport client.Transport) {
	a.transport = transport
}
