package constraints

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-swagger/go-swagger/client"

	strfmt "github.com/go-swagger/go-swagger/strfmt"
)

// New creates a new constraints API client.
func New(transport client.Transport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for constraints API
*/
type Client struct {
	transport client.Transport
	formats   strfmt.Registry
}

/*
DeleteConstraintsAccountName deletes public owned or private constraint template by name

A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like Mesos.
*/
func (a *Client) DeleteConstraintsAccountName(params *DeleteConstraintsAccountNameParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteConstraintsAccountNameParams()
	}

	_, err := a.transport.Submit(&client.Operation{
		ID:                 "DeleteConstraintsAccountName",
		Method:             "DELETE",
		PathPattern:        "/constraints/account/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteConstraintsAccountNameReader{formats: a.formats},
	})
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteConstraintsID deletes constraint template by id

A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like Mesos.
*/
func (a *Client) DeleteConstraintsID(params *DeleteConstraintsIDParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteConstraintsIDParams()
	}

	_, err := a.transport.Submit(&client.Operation{
		ID:                 "DeleteConstraintsID",
		Method:             "DELETE",
		PathPattern:        "/constraints/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteConstraintsIDReader{formats: a.formats},
	})
	if err != nil {
		return err
	}
	return nil
}

/*
DeleteConstraintsUserName deletes private constraint template by name

A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like Mesos.
*/
func (a *Client) DeleteConstraintsUserName(params *DeleteConstraintsUserNameParams) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteConstraintsUserNameParams()
	}

	_, err := a.transport.Submit(&client.Operation{
		ID:                 "DeleteConstraintsUserName",
		Method:             "DELETE",
		PathPattern:        "/constraints/user/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &DeleteConstraintsUserNameReader{formats: a.formats},
	})
	if err != nil {
		return err
	}
	return nil
}

/*
GetConstraintsAccount retrieves public and private owned constraint templates

A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like Mesos.
*/
func (a *Client) GetConstraintsAccount(params *GetConstraintsAccountParams) (*GetConstraintsAccountOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetConstraintsAccountParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "GetConstraintsAccount",
		Method:             "GET",
		PathPattern:        "/constraints/account",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetConstraintsAccountReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConstraintsAccountOK), nil
}

/*
GetConstraintsAccountName retrieves a public or private owned constraint template by name

A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like Mesos.
*/
func (a *Client) GetConstraintsAccountName(params *GetConstraintsAccountNameParams) (*GetConstraintsAccountNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetConstraintsAccountNameParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "GetConstraintsAccountName",
		Method:             "GET",
		PathPattern:        "/constraints/account/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetConstraintsAccountNameReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConstraintsAccountNameOK), nil
}

/*
GetConstraintsID retrieves constraint template by id

A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like Mesos.
*/
func (a *Client) GetConstraintsID(params *GetConstraintsIDParams) (*GetConstraintsIDOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetConstraintsIDParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "GetConstraintsID",
		Method:             "GET",
		PathPattern:        "/constraints/{id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetConstraintsIDReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConstraintsIDOK), nil
}

/*
GetConstraintsUser retrieves private constraint templates

A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like Mesos.
*/
func (a *Client) GetConstraintsUser(params *GetConstraintsUserParams) (*GetConstraintsUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetConstraintsUserParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "GetConstraintsUser",
		Method:             "GET",
		PathPattern:        "/constraints/user",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetConstraintsUserReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConstraintsUserOK), nil
}

/*
GetConstraintsUserName retrieves a private constraint template by name

A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like Mesos.
*/
func (a *Client) GetConstraintsUserName(params *GetConstraintsUserNameParams) (*GetConstraintsUserNameOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetConstraintsUserNameParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "GetConstraintsUserName",
		Method:             "GET",
		PathPattern:        "/constraints/user/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &GetConstraintsUserNameReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetConstraintsUserNameOK), nil
}

/*
PostConstraintsAccount creates constraint template as public resource

A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like Mesos.
*/
func (a *Client) PostConstraintsAccount(params *PostConstraintsAccountParams) (*PostConstraintsAccountOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostConstraintsAccountParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "PostConstraintsAccount",
		Method:             "POST",
		PathPattern:        "/constraints/account",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostConstraintsAccountReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConstraintsAccountOK), nil
}

/*
PostConstraintsUser creates constraint template as private resource

A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like Mesos.
*/
func (a *Client) PostConstraintsUser(params *PostConstraintsUserParams) (*PostConstraintsUserOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostConstraintsUserParams()
	}

	result, err := a.transport.Submit(&client.Operation{
		ID:                 "PostConstraintsUser",
		Method:             "POST",
		PathPattern:        "/constraints/user",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http", "https"},
		Params:             params,
		Reader:             &PostConstraintsUserReader{formats: a.formats},
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostConstraintsUserOK), nil
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport client.Transport) {
	a.transport = transport
}
